clase 2 dia 3

1 = asignacion, == 2 comparacion (== si es igual)



- maineje.js

La función substring:

Permite extraer parte de una cadena. Este método lo tienen todos los strings de JavaScript. La sintaxis es:
    "let cadenaExtraida = cadena.substring(inicio, fin);"

ejemplo:
let cadena = "parzibyte.me";
let extraida = cadena.substring(0, 9);
console.log("Extraída: ", extraida);
/*
Salida:
Extraída:  parzibyte
*/
------------------------------------------------------------------------
Extraer cadena a partir de carácter:

En este caso tenemos la posición o índice de un carácter (el espacio en blanco) a través de indexOf.

A partir del mismo extraemos parte de la cadena, desde 0 hasta el índice obtenido.

De esta manera podemos cortar cadenas en JavaScript basándonos en caracteres buscados usando indexOf.

Recuerda que igualmente puedes cambiar el índice de inicio, no siempre debe ser cero.

let cadena = "JavaScript es un lenguaje muy bueno";
// Buscamos el índice del espacio

let indice = cadena.indexOf(" ");
// Cortar desde 0 hasta la aparición del primer espacio
let extraida = cadena.substring(0, indice);
console.log("Extraída: ", extraida);
/*
Salida:
Extraída:  JavaScript
*/
---------------------------------------------------------------------------
substring y substr en JavaScript: [str.includes(searchString[, position])]

Además de substring, en JavaScript existe la función substr que toma el inicio desde dónde comenzar a cortar la cadena, y la cantidad de caracteres que se deben tomar.

Si te confundes, te recomiendo que uses substring pues es lo más entendible y deseable. Pero para comprobar la diferencia, veamos el siguiente ejemplo:

ejemplo:

let cadena = "JavaScript es un lenguaje muy bueno";
// Este extrae de inicio a fin:
let conSubstring = cadena.substring(17, 25);
console.log("Con substring: ", conSubstring);
// Este extrae N caracteres desde inicio
let conSubstr = cadena.substr(17, 25);
console.log("Con substr: ", conSubstr);
/*
Salida:
Con substring:  lenguaje
Con substr:  lenguaje muy bueno
*/

En la línea 10 estamos usando substring, tomando lo que haya desde la posición 17 hasta la 25.

En cambio, en la línea 13 estamos usando substr tomando 25 caracteres a partir de la posición 17.

Esa es la diferencia, que substring corta desde inicio hasta fin, y substr toma N caracteres a partir de inicio.
-----------------------------------------------------------------
String.prototype.includes():

El método includes() determina si una cadena de texto puede ser encontrada dentro de otra cadena de texto, devolviendo true o false según corresponda.

ejemplo:
const sentence = 'The quick brown fox jumps over the lazy dog.';

const word = 'fox';

console.log(`The word "${word}" ${sentence.includes(word) ? 'is' : 'is not'} in the sentence`);
// Expected output: "The word "fox" is in the sentence"
-----------------------------------------------------------------
Array:

El objeto Array de JavaScript es un objeto global que es usado en la construcción de arrays, que son objetos tipo lista de alto nivel.

ejemplo:

let frutas = ["Manzana", "Banana"]//este array es usado para los demas accesos abajo !OJO

console.log(frutas.length)
// 2

- Acceder a un elemento de Array mediante su índice

let primero = frutas[0]
// Manzana

let ultimo = frutas[frutas.length - 1]
// Banana

- Recorrer un Array

frutas.forEach(function(elemento, indice, array) {
    console.log(elemento, indice);
})
// Manzana 0
// Banana 1

- Añadir un elemento al final de un Array

let nuevaLongitud = frutas.push('Naranja') // Añade "Naranja" al final
// ["Manzana", "Banana", "Naranja"]

- Eliminar el último elemento de un Array

let ultimo = frutas.pop() // Elimina "Naranja" del final
// ["Manzana", "Banana"]

- Añadir un elemento al principio de un Array

let nuevaLongitud = frutas.unshift('Fresa') // Añade "Fresa" al inicio
// ["Fresa" ,"Manzana", "Banana"]

- Eliminar el primer elemento de un Array

let primero = frutas.shift() // Elimina "Fresa" del inicio
// ["Manzana", "Banana"]

- Encontrar el índice de un elemento del Array

frutas.push('Fresa')
// ["Manzana", "Banana", "Fresa"]

let pos = frutas.indexOf('Banana') // (pos) es la posición para abreviar
// 1

- Eliminar un único elemento mediante su posición

Ejemplo:
Eliminamos "Banana" del array pasándole dos parámetros: la posición del primer elemento que se elimina y el número de elementos que queremos eliminar. De esta forma, .splice(pos, 1) empieza en la posición que nos indica el valor de la variable pos y elimina 1 elemento. En este caso, como pos vale 1, elimina un elemento comenzando en la posición 1 del array, es decir "Banana".

let elementoEliminado = frutas.splice(pos, 1)
// ["Manzana", "Fresa"]

- Eliminar varios elementos a partir de una posición parte 2

Nota:
Con .splice() no solo se puede eliminar elementos del array, si no que también podemos extraerlos guardándolo en un nuevo array. ¡Ojo! que al hacer esto estaríamos modificando el array de origen.

let vegetales = ['Repollo', 'Nabo', 'Rábano', 'Zanahoria']
console.log(vegetales)
// ["Repollo", "Nabo", "Rábano", "Zanahoria"]

let pos = 1, numElementos = 2

let elementosEliminados = vegetales.splice(pos, numElementos)
// ["Nabo", "Rábano"] ==> Lo que se ha guardado en "elementosEliminados"

console.log(vegetales)
// ["Repollo", "Zanahoria"] ==> Lo que actualmente tiene "vegetales"

- Copiar un Array

let copiaArray = vegetales.slice();
// ["Repollo", "Zanahoria"]; ==> Copiado en "copiaArray"

- Acceso a elementos de un array:

Los índices de los arrays de JavaScript comienzan en cero, es decir, el índice del primer elemento de un array es 0, y el del último elemento es igual al valor de la propiedad length del array restándole 1.

Si se utiliza un número de índice no válido, se obtendrá undefined.

let arr = ['este es el primer elemento', 'este es el segundo elemento', 'este es el último elemento']
console.log(arr[0])              // escribe en consola 'este es el primer elemento'
console.log(arr[1])              // escribe en consola 'este es el segundo elemento'
console.log(arr[arr.length - 1]) // escribe en consola 'este es el último elemento'

No hay nada especial ni en los arrays de JavaScript ni en sus propiedades que ocasione esto. En JavaScript, las propiedades cuyo nombre comienza con un dígito no pueden referenciarse con la notación punto y debe accederse a ellas mediante la notación corchete.

Por ejemplo, dado un objeto con una propiedad de nombre '3d', sólo podría accederse a dicha propiedad con la notación corchete.

let decadas = [1950, 1960, 1970, 1980, 1990, 2000, 2010]
console.log(decadas.0)  // error de sintaxis
console.log(decadas[0]) // funciona correctamente

- otro ejemplo:

renderizador.3d.usarTextura(modelo, 'personaje.png')
renderizador['3d'].usarTextura(modelo, 'personaje.png')

Obsérvese que, en el último ejemplo, ha sido necesario poner '3d' entre comillas. Es posible usar también comillas con los índices del los arrays de JavaScript (p. ej., decadas['2'] en vez de decadas[2]), aunque no es necesario.

El motor de JavaScript transforma en un string el 2 de decadas[2] a través de una conversión implícita mediante toString. Por tanto, '2' y '02' harían referencia a dos posiciones diferentes en el objeto decadas, y el siguiente ejemplo podría dar true como resultado:

console.log(decadas['2'] != decadas['02'])
-----------------------------------------------------------------
//Probando
let stock = ['cerveza','refresco','patatas']

stock.forEach(function(elemento, indice, array) {
    console.log(elemento, indice);})

    pos = stock.indexOf('refresco') // (pos) es la posición para abreviar ojo: pos no se puede declarar dos veces asi que al de esta linea le quite el let

    let elementoEliminado = stock.splice(pos, 1)
    console.log(elementoEliminado); //por que en el splice al parecer se declara de nuevo
    
    stock.forEach(function(elemento, indice, array) {
        console.log(elemento, indice);})

.......................................................................................
function

- como declarar:
Se declara a través de la palabra reservada function. Deben tener un nombre en minúscula y sin espacios seguidos de los característicos paréntesis (). El contenido de la función se escribe entre las llaves. El nombre de la función no se puede repetir en otra.

function saludar() {
    console.log("Hola estudiantes");
}

- llamado:
Una vez que declaramos la función, podemos usarla en cualquier otra parte del código todas las veces que queramos. 
Para ejecutar una función sólo hay que escribir su nombre y finalizar la sentencia con (). A esto se lo conoce como llamado a la función.

saludar();

Donde escribamos el llamado, se interpretarán las instrucciones definidas en esa función.

ejemplo:
function solicitarNombre(){
    let nombreIngresado   = prompt("Ingresar nombre")
    alert("El nombre ingresado es " + nombreIngresado)
} 

para llamarlo:

solicitarNombre();
solicitarNombre();
solicitarNombre();

- Parametros:
Cuando enviamos a la función uno o más valores para ser empleados en sus operaciones, estamos hablando de los parámetros de la función.

Los parámetros son variables que se declaran dentro de la función, entre sus paréntesis. Los valores de éstos se definen luego en el llamado.

function conParametros(parametro1, parametro2) {
    console.log(parametro1 + " " + parametro2);
}

Así, podemos armar funciones dinámicas que, siguiendo la lógica que queramos, pueden generar distintos resultados al recibir diferentes valores.

El valor que toman estos parámetros se definen en el llamado. Cuando llamamos a la función, los valores que pasamos a la función entre paréntesis se asignan posicionalmente a los parámetros correspondientes, generando posibles resultados diferentes:

conParametros("Hola", "Coder"); // -> “Hola Coder”
conParametros("Cursando", "JS"); // -> “Cursando JS”

Ejemplo de sumar y restar:

//Declaración de variable para guardar el resultado de la suma
let resultado = 0;
//Función que suma dos números y asigna a resultado
function sumar(primerNumero, segundoNumero) {
    resultado = primerNumero + segundoNumero
}
//Función que muestra resultado por consola
function mostrar(mensaje) {
    console.log(mensaje)
}
//Llamamos primero a sumar y luego a mostrar
sumar(6, 3);            
mostrar(resultado); 

//Resultado de una función:
En el ejemplo anterior sumamos dos números a una variable declarada anteriormente. Pero las funciones pueden generar un valor de retorno usando la palabra return, obteniendo el valor cuando la función es llamada.

function sumar(primerNumero, segundoNumero) {
    return primerNumero + segundoNumero;
}
let resultado = sumar(5, 8);

La función puede comportarse como una operación que genera valores (como en las operaciones matemáticas y lógicas previas). 
En el espacio donde se llama a la función se genera un nuevo valor: este valor es el definido por el return de la misma.

let resultado = sumar(5, 8);

console.log(resultado)  // ⇒ 13


- Scope:
El scope o ámbito de una variable es la zona del programa en la cual se define, el contexto al que pertenece la misma dentro de un algoritmo, restringiendo su uso y alcance.

JavaScript define dos ámbitos para las variables: 
global y local.

- Globales
let resultado = 0
function sumar(primerNumero, segundoNumero) {
    resultado = primerNumero + segundoNumero;
}
sumar(5,6);
//Se puede acceder a la variable resultado porque es global
console.log(resultado);

Puede ser referenciada desde cualquier punto del programa.

- Locales:
Cuando definimos una variable dentro de una función o bloque es una variable local,  y será accesible sólo dentro de ese espacio. Si queremos utilizarla por fuera, la variable no existirá para JS.


function sumar(primerNumero, segundoNumero) {
    let resultado = primerNumero + segundoNumero;
}
//No se puede acceder a la variable resultado fuera del bloque
console.log(resultado);

- Ejemplo variabl slocales y Globales:

let nombre = “John Doe” // variable global

function saludar() {
    let nombre = “Juan Coder” // variable local
    console.log(nombre)
}
//Accede a nombre global
console.log(nombre)   // → “John Doe”

//Accede a nombre local
saludar() // → “Juan Coder”

Hay que entender que las variables globales y locales se identifican como diferentes entre sí, y pueden existir en el programa bajo el mismo nombre sin conflicto.

-Scope:

Entender que cada scope local es un espacio cerrado nos permite crear bloques de trabajo bien diferenciados e independientes, sin preocuparnos por repetir nombres de variables, sabiendo que se entienden como diferentes según donde las llamemos.

function sumar(num1, num2) {
     let resultado = num1 + num2
	 return resultado
}

function restar(num1, num2) {
     let resultado = num1 - num2
	 return resultado
}

-Funiones anonimas:
Una función anónima es una función que se define sin nombre y se utiliza para ser pasada como parámetro o asignada a una variable. En el caso de asignarla a una variable, pueden llamar usando el identificador de la variable declarada.

//Generalmente, las funciones anónimas se asignan a variables declaradas como constantes
const suma  = function (a, b) { return a + b }
const resta = function (a, b) { return a - b }
console.log( suma(15,20) )
console.log( resta(15,5) )

// FUNCIONES FLECHAS:
Identificamos a las funciones flechas como funciones anónimas de sintaxis simplificada. Están disponibles desde la versión ES6 de JavaScript, no usan la palabra function pero usa => (flecha) entre los parámetros y el bloque.

const suma  = (a, b) => { return a + b }
//Si es una función de una sola línea con retorno podemos evitar escribir el cuerpo.
const resta = (a, b) =>  a - b ;
console.log( suma(15,20) )
console.log( resta(20,5) )
----------------------------------------------------------------------
Objetos:
En JS, los objetos son estructuras que podemos definir para agrupar valores bajo un mismo criterio. Podemos decir que un objeto es una colección de datos relacionados como una entidad. Se componen de un listado de pares clave-valor, es decir, contienen propiedades y valores agrupados.

La utilidad de los objetos deviene de su composición por varios valores y operaciones comunes (funciones) para todos los elementos de este tipo y sus propiedades".

Un objeto literal se define directamente entre llaves { }
Los valores que almacenan se listan separados por coma, bajo la forma propiedad: valor

const persona1 = { 
     nombre: "Homero", 
     edad: 39, 
     calle: "Av. Siempreviva 742" 
}

ejemplo:

const persona1 = { nombre: "Homero",
                   edad: 39,
                   calle: "Av. Siempreviva 742"}
                   
console.log(persona1.nombre) // Homero
console.log(persona1.edad) // 39
console.log(persona1.calle) // Av. Siempreviva 742

- Asignar valores a las propiedades
Es posible usar las dos formas( corchetes y paréntesis) para acceder a las propiedades y asignar nuevos valores a los datos almacenados en las propiedades del objeto.

ejemplo:

const persona1 = { nombre: "Homero",
                   edad: 39,
                   calle: "Av. Siempreviva 742"}
                   
persona1["nombre"] = "Marge" //asigna un valor nuevo o dato dentro del objeto
persona1.edad = 36

-- Objetos y contructorefa

- Constructores:
En JS, el constructor de un objeto es una función que usamos para crear un nuevo objeto cada vez que sea necesario. Con esta “función constructora” podemos inicializar las propiedades del objeto al momento de ser instanciado con new.

ejemplo"
function Persona(nombre, edad, calle) {
    this.nombre = nombre;
    this.edad 	 = edad;
    this.calle  = calle;
}
const persona1 = new Persona("Homero", 39, "Av. Siempreviva 742"); //asi se invoca al contructor
const persona2 = new Persona("Marge", 36, "Av. Siempreviva 742");

- Constructor y New
En el ejemplo anterior, se define la función Persona, donde se asignan las diferentes propiedades con los valores recibidos como parámetros.

Luego, en algún lugar del código posterior a esas líneas, se puede construir un objeto Persona declarando una variable y asignando la referencia del objeto instanciado mediante la instrucción new Persona(...)

-- uso del this
La palabra clave this (“este”) refiere al elemento actual en el que se está escribiendo el código.  Cuando se emplea un función constructora para crear un objeto (con la palabra clave new), this está enlazado al nuevo objeto instanciado.
This es muy útil para asegurar que se emplean las propiedades del objeto actual.

ejemplo:
function Persona(literal) {//literal es un objeto
    this.nombre = literal.nombre; 
    this.edad   = literal.edad;
    this.calle  = literal.calle;
}
const persona1 = new Persona({ nombre: "Homero", edad: 39, calle: "Av.Siempreviva 742" });// palabra reservada new

-- Metoos y operaciones con objetos

- METODO <> FUNCION:
Como vimos anteriormente, las funciones en JS se pueden definir en cualquier parte del código, y pueden ser llamadas desde cualquier otra parte del código posterior.

Los métodos de los objetos también son técnicamente funciones, sólo que se limitan a poder ser ejecutados solo desde el mismo objeto.

Funcion
//Funciones: Generalmente retornar un valor y son de acceso global.
function f1(){
    return this;
}

METODO
//Métodos: Se requiere un objeto y puede no retornar un valor.
function Persona(nombre, edad, calle) {
    this.nombre = nombre;
    this.edad = edad;
    this.calle = calle;
}

- Metodos en objetos JS

JavaScript cuenta con sus propios objetos, incluso ya usamos algunos de ellos sin identificar que son objeto.
Por ejemplo: Cada vez que creamos una cadena de caracteres se crea automáticamente como una instancia del objeto String y, por lo tanto, tiene varios métodos/propiedades comunes disponibles en ella.

ejemplo
let cadena = "HOLA CODER";
//Propiedad de objeto String: Largo de la cadena.
console.log(cadena.length);
//Método de objeto String: Pasar a minúscula.
console.log(cadena.toLowerCase());
//Método de objeto String: Pasar a mayúscula.
console.log(cadena.toUpperCase());


- Metodos personalizadofa-spin
Podemos crear nuestros propios métodos para objetos personalizados, referenciando funciones por su nombre o definiendo funciones anónimas asociadas a una propiedad de la función constructora. 
Llamar a un método es similar a acceder a una propiedad, pero se agrega () al final del nombre del método, posiblemente con argumentos.

ejemplo:
function Persona(nombre, edad, calle) {
    this.nombre = nombre;
    this.edad   = edad;
    this.calle  = calle;
    this.hablar = function(){ console.log("HOLA SOY "+ this.nombre)}
}
const persona1 = new Persona("Homero", 39, "Av. Siempreviva 742");
const persona2 = new Persona("Marge", 36, "Av. Siempreviva 742");
persona1.hablar();
persona2.hablar();

- Operador IN Y FOR.... IN
El operador in devuelve true si la propiedad especificada existe en el objeto. 
Mientras que el bucle for...in permite acceder a todas las propiedades del objeto, obteniendo una propiedad por cada iteración.


ejemplo:
const persona1 = { nombre: "Homero", edad: 39, calle: "Av. Siempreviva 742"};
//devuelve true porque la clave "nombre" existe en el objeto persona1
console.log( "nombre" in persona1);
//devuelve false porque la clave "origen" no existe en el objeto persona1
console.log( "origen" in persona1);
//recorremos todas las propiedades del objeto con el ciclo for...in
for (const propiedad in persona1) {
    console.log(persona1[propiedad]);
}

-- CLASES

Las clases de JavaScript, introducidas en ES6, proveen una sintaxis mucho más clara y simple para crear objetos personalizados.
Son una equivalencia al empleo de función constructora y permite definir distintos tipos de métodos. 


ejemplo:
class Persona{
    constructor(nombre, edad, calle) {
        this.nombre = nombre;
        this.edad   = edad;
        this.calle  = calle;
    }
}
const persona1 = new Persona("Homero", 39, "Av. Siempreviva 742");

- CLASES Y Metodos
En la declaración de clase, la función constructora es reemplazada por el método constructor. Los métodos en las clases no referencian a propiedades, se declaran dentro del bloque sin la palabra function.


ejemplo:
class Persona{
    constructor(nombre, edad, calle) {
        this.nombre = nombre;
        this.edad   = edad;
        this.calle  = calle;
    }
    hablar(){
        console.log("HOLA SOY "+ this.nombre);
    }
}
const persona1 = new Persona("Homero", 39, "Av. Siempreviva 742");
persona1.hablar();

- Ejemplo
class Producto {
    constructor(nombre, precio) {
        this.nombre  = nombre.toUpperCase();
        this.precio  = parseFloat(precio);
        this.vendido = false;
    }
    sumaIva() {
        this.precio = this.precio * 1.21;
    }
    vender() {
        this.vendido = true;
    }
}
const producto1 = new Producto("arroz", "125");
const producto2 = new Producto("fideo", "50");
producto1.sumaIva();
producto2.sumaIva();
producto1.vender();

- RESUMEN DE LO VISTO
Los objetos tienen propiedades y métodos.
El método constructor de un objeto sirve para crear el mismo y asignarle sus propiedades. Permite crear varios objetos usando el mismo constructor.
Las funciones de JS son generalmente de acceso global y los métodos son únicamente utilizados para ser invocados por los objetos que lo contienen.
Las clases son otra forma de crear objetos personalizados en JS.

----------------------------------------------------------------------Dia 7 arrays

- ARRAYS: 
Un Array es un tipo de dato que sirve para almacenar valores en forma de lista. Puede ser una colección de números, strings, booleanos, objetos o hasta una lista de listas. 

Los valores del array pueden ser distintos y es posible agregar o quitar elementos en todo momento.

Los elementos del array tienen un índice, que va desde el 0 (el primer elemento del array) hasta el último elemento.

- Declaración del array
Para declarar una variable y asignar un array empleamos los corchetes ([ ]) y dentro de ellos definimos todos los valores separados por coma.
Los arrays en Javascript empiezan siempre en la posición 0. Un array que tenga, por ejemplo, 10 elementos, tendrá posiciones de 0 a  9.

Ejemplo:
// Declaraciòn de array vacío
const arrayA = [];
// Declaracion de array con nùmeros
const arrayB = [1,2];
// Declaracion de array con strings
const arrayC = ["C1","C2","C3"];
// Declaracion de array con booleanos
const arrayD = [true,false,true,false];
// Declaracion de array mixto
const arrayE = [1,false,"C4"];

-Acceso al array
Los elementos dentro de un array tienen un índice que determina su posición en el mismo. 
Así, es posible acceder a los elementos dentro de un array a través de su posición:

Ejemplo:
const  numeros = [1,2,3,4,5];
console.log( numeros[0] ) // 1; 
console.log( numeros[3] ) // 4; 
let resultado  = numeros[1] + numeros[2] 
console.log( resultado  ) // 5;

- Recorrido del arrays
Decimos que estamos recorriendo un Array cuando empleamos un bucle para acceder a cada elemento por separado.
Los Array en JavaScript son objetos iterables, lo que permite usar distintas estructuras para iterar sobre ellos.

ejemplo:
const numeros = [1, 2, 3, 4, 5];
for (let index = 0; index < 5; index++) {
    alert(numeros[index]);
}


- Métodos y propiedades

. Length:
Al igual que en un String, la propiedad length nos sirve para obtener el largo de un Array, es decir, para identificar cuántos elementos tiene.

ejemplo:
const miArray = ["marca", 3 ,"palabra"];
console.log( miArray.length ); //imprime 3

Es común utilizarlo para definir el límite de una iteración sobre un array, ya que la propiedad length me permite saber explícitamente la longitud del mismo:

ejemplo:

const numeros = [1, 2, 3, 4, 5, 6, 7, 8]

for (let i= 0; i < numeros.length; i++) {
    alert(numeros[i]);
}

- Agregar elementos

Para sumar un elemento a un Array ya existente, se utiliza el método push, pasando como parámetro el valor (o variable) a agregar.

ejemplo:
const miArray = ["marca", 3, "palabra"]
miArray.push('otro elemento')

console.log(miArray.length) // ⇒ 4
console.log(miArray)
//["marca", 3, "palabra", “otro elemento”]

El método push () agrega elementos al final del array. Si queremos agregar al inicio del array, utilizamos el método unshift() de forma similar:

const miArray = ["marca", 3, "palabra"]

miArray.unshift('otro elemento')

console.log(miArray)
//[“otro elemento”, "marca", 3, "palabra"]

//Eliminar elementos
De forma inversa, existen métodos para eliminar elementos del array.

Si queremos eliminar el primer elemento del array utilizamos el método shift(); y si queremos eliminar el último elemento, el método pop().


//Pop y shift
ejemplo:

const nombres = ["Luis", "Ana", "Julia", “Juan”]

nombres.pop()
console.log(nombres) // ["Luis", "Ana", "Julia"]

nombres.shift()
console.log(nombres) // ["Ana", "Julia"]

//splice
El método splice() permite eliminar uno o varios elementos de un array en cualquier posición. Funciona con 2 parámetros: el primero es el índice donde se ubica el método para trabajar, y el segundo es la cantidad de elementos a eliminar desde esa posición.

ejemplo:
const nombres = ['Rita', 'Pedro', 'Miguel', 'Ana', 'Vanesa'];
nombres.splice(1, 2)

console.log(nombres)
// ['Rita', 'Ana', 'Vanesa']

//Join
Mediante el método join podemos generar un string con todos los elementos del array, separados por el valor que pasamos por parámetro:

const nombres = ["Luis", "Ana", "Julia", “Juan”]

console.log( nombres.join(“, ”) ) 
// Luis, Ana, Julia

console.log( nombres.join(“*”) ) 
// Luis*Ana*Julia

-constructora
Mediante el método concat podemos combinar dos Arrays en un único Array resultante:
const perros   = ["Pupy", “Ronnie”]
const gatos = ["Mishi", “Garfield”, "Zuri"]
const mascotas = perros.concat(gatos)
console.log(mascotas)
// ["Pupy", “Ronnie”, "Mishi", “Garfield”, "Zuri"]

-slice
El método slice devuelve una copia de una parte del Array dentro de un nuevo Array, empezando por el inicio hasta fin (fin no incluído). El Array original no se modificará.

ejemplo:
const nombres    = ['Rita', 'Pedro', 'Miguel', 'Ana', 'Vanesa'];
const masculinos = nombres.slice(1, 3); // Nuevo array desde la posición 1 a 3.
// masculinos contiene ['Pedro','Miguel']

-indexOf
El método indexOf() nos permite obtener el índice de un elemento en un array. Recibe por parámetro el elemento que queremos buscar en el array y, en caso de existir, nos retorna su índice. Si el elemento no existe nos retornará como valor: -1

ejemplo:
const nombres = ['Rita', 'Pedro', 'Miguel', 'Ana', 'Vanesa'];

console.log( nombres.indexOf('Rita') ) // ⇒ 0
console.log( nombres.indexOf('Ana') ) // ⇒ 3
console.log( nombres.indexOf('Julieta') ) // ⇒ -1

-includes
Similar al anterior, el método includes me permite saber si un elemento que recibo por parámetro existe o no dentro de un array, retornando un valor booleano en caso afirmativo o negativo:

Ejemplo:
const nombres = ['Rita', 'Pedro', 'Miguel', 'Ana', 'Vanesa']

console.log( nombres.includes('Rita') ) // ⇒ true
console.log( nombres.includes('Miguel') ) // ⇒ true
console.log( nombres.includes('Julieta') ) // ⇒ false

-Reverse
Como su nombre lo indica, el método reverse() invierte el orden de los elementos dentro de un array.

ejemplo:
const nombres = ['Rita', 'Pedro', 'Miguel', 'Ana', 'Vanesa']
nombres.reverse()
console.log( nombres ) 
// ⇒ ['Vanesa', 'Ana','Miguel', 'Pedro','Rita']

Cuidado porque el método reverse es destructivo, o sea que modifica el array original, al igual que los métodos para agregar o quitar elementos.

-Array de objetos
Los array pueden usarse para almacenar objetos personalizados. Podemos asignar objetos literales o previamente instanciados en la declaración del array o agregar nuevos objetos usando el método push y el constructor.

ejemplos:
const objeto1 = { id: 1, producto: "Arroz" };
const array   = [objeto1, { id: 2, producto: "Fideo" }];
array.push({ id: 3, producto: "Pan" });

¡Arrays + Objetos!

La combinación de arrays con objetos genera estructuras complejas de datos. 

¡Los métodos de arrays y las herramientas para recorrerlos nos permiten acceder y manipular todos estos datos de forma precisa y prolija!

-For ...of
La sentencia for...of permite recorrer un array ejecutando un bloque de código por cada elemento del objeto.

ejemplo:
const productos = [{ id: 1, producto: "Arroz" },
                  { id: 2,  producto: "Fideo" },
                  { id: 3,  producto: "Pan" }];

for (const producto of productos) {
    console.log(producto.id);
    console.log(producto.producto);

-Obejtos productos y arrays

class Producto {
    constructor(nombre, precio) {
        this.nombre  = nombre.toUpperCase();
        this.precio  = parseFloat(precio);
        this.vendido = false;
    }
    sumaIva() {
        this.precio = this.precio * 1.21;
    }
}
//Declaramos un array de productos para almacenar objetos
const productos = [];
productos.push(new Producto("arroz", "125"));
productos.push(new Producto("fideo", "70"));
productos.push(new Producto("pan", "50"));
//Iteramos el array con for...of para modificarlos a todos
for (const producto of productos)
producto.sumaIva();

-------------------------------------------------------------------------------------------------------------------------------------
Dia 8 Funciones de Orden superior

-Abstraccion

Para meternos de lleno en el tema de hoy, antes necesitamos mirar un poco atrás. Empecemos por analizar el siguiente código. 
Se declara una variable que, a través de un iterador, va acumulando la suma del contador:

ejemplo:

let total = 0
for (let i = 1; i <= 10; i++) {
    total += i
}

console.log(total)  //  55

Ahora lo presentamos resumido en una función, y ocupa solo una línea de código:

console.log( sumarRango(1, 10) ) //  55


/*4374-2485

REQUISITOS DIARIO JUDICIAL
1140462814
1156344262
154046-2814*/

Dia 9 Dom

- Dom: Un Dom es (Document Object Model), se podria decir que es un objeto que nos permite manipular las etiquetas en html y su contenido

El Modelo de Objetos del Documento (DOM) es una estructura de objetos generada por el navegador, la cual representa la página HTML actual. 

- Estructura Dom

* Cada etiqueta HTML se transforma en un nodo de tipo "Elemento". La conversión se realiza de forma jerárquica.

* De esta forma, del nodo raíz solamente pueden derivar los nodos HEAD y BODY.

* Cada etiqueta HTML se transforma en un nodo que deriva del correspondiente a su "etiqueta padre".

* La transformación de las etiquetas HTML habituales genera dos nodos. =>
1. Nodo elemento: correspondiente a la propia etiqueta HTML.
2. Nodo texto: contiene el texto encerrado por esa etiqueta HTML.
-------------------------------------------------------------------

Que es el console.dir: 
El método console.dir() es una función de depuración integrada en JavaScript que le permite inspeccionar y registrar las propiedades y métodos de un objeto de JavaScript en un formato de árbol en la consola.

Tipos de Nodo: La especificación completa de DOM define 12 tipos de nodos, los más usados son:

Document: Nodo raíz del que derivan todos los demás nodos del árbol.

Element: Representa cada una de las etiquetas XHTML. Puede contener atributos y derivar otros nodos de él.

Attr: Se define un nodo de este tipo para representar cada uno de los atributos de las etiquetas HTML, es decir, uno por cada par atributo=valor.

Text: Nodo que contiene el texto encerrado por una etiqueta HTML.

Comment: Representa los comentarios incluidos en la página HTML.

----------------------------------------------------------
Acceso al Dom

Existen distintos métodos para acceder a los elementos del DOM empleando en la clase Document. 

Los más comunes son:

getElementById(): El método getElementById() sirve para acceder a un elemento de la estructura HTML, utilizando su atributo ID como identificación. <div id = "app"></div>

getElementsByClassName(): El método getElementsByClassName() sirve para acceder a un conjunto de elementos de la estructura HTML, utilizando su atributo class como identificación. Se retornará un Array de elementos con todas las coincidencias.<div class = "app"></div>

getElementsByTagName(): El método getElementsByTagName() sirve para acceder a un conjunto de elementos de la estructura HTML, utilizando su nombre de etiqueta como identificación. Esta opción es la menos específica de todas, ya que es muy probable que las etiquetas se repitan en el código HTML. <h1></h1>
---------------------------------------------------------------------------------------
Modificar nodos

Inner Text:La propiedad innerText de un nodo nos permite modificar su nodo de texto. Es decir, acceder y/o modificar el contenido textual de algún elemento del DOM.

ejemplo:
//CODIGO HTML DE REFERENCIA
<h1 id=”titulo”>Hola Mundo!</h1>

//CODIGO JS 
let titulo = document.getElementById("titulo")
console.log( titulo.innerText ) // “Hola Mundo!”

// cambio el contenido del elemento
titulo.innerText = “Hola Coder!”
console.log( titulo.innerText ) // “Hola Coder!”

innerHTML: Permite definir el código html interno del elemento seleccionado. El navegador lo interpreta como código HTML y no como contenido de texto, permitiendo desde un string crear una nueva estructura de etiquetas y contenido. 

Al pasar un string con formato de etiquetas html y contenido a través de la propiedad innerHTML, el navegador genera nuevos nodos con su contenido dentro del elemento seleccionado. 

ejemplo:
//CODIGO HTML DE REFERENCIA

<div id=”contenedor”></div>

//CODIGO JS

let container = document.getElementById("contenedor")
// cambio el código HTML interno
container.innerHTML = “<h2>Hola mundo!</h2><p>Lorem ipsum</p>”

//Resultado en el DOM

<div id=”contenedor”>
    <h2>Hola mundo!</h2>
    <p>Lorem ipsum</p>
</div>

Class Name: A través de la propiedad className de algún nodo seleccionado podemos acceder al atributo class del mismo y definir cuáles van a ser sus clases:

//CODIGO HTML DE REFERENCIA
<div id=”contenedor”></div>
//CODIGO JS

let container = document.getElementById("contenedor")
// cambio el código HTML interno

container.innerHTML = “<h2>Hola mundo!</h2>”
// cambio el atributo class

container.className = “container row”
//Resultado en el DOM

<div id=”contenedor” class=“container row”>
    <h2>Hola mundo!</h2>
</div>

Agregar y quitar nodos: Para crear elementos se utiliza la función document.createElement(), y se debe indicar el nombre de etiqueta HTML que representará ese elemento.
Luego debe agregarse como hijo el nodo creado con append(), al body o a otro nodo del documento actual.

Ejemplo:
// Crear nodo de tipo Elemento, etiqueta "p"

let parrafo = document.createElement("p");
// Insertar HTML interno

parrafo.innerHTML = "<h2>¡Hola Coder!</h2>"; 
// Añadir el nodo Element como hijo de body

document.body.append(parrafo);

Eliminar elementos: Se pueden eliminar nodos existentes y nuevos. El método remove() permite eliminar un nodo seleccionado del DOM:

let parrafo = document.getElementById("parrafo1");
//Elminando el propio elemento
parrafo.remove();

let paises = document.getElementsByClassName("paises");
//Eliminando el primer elemento de clase paises
paises[0].remove()

-------------------------------------------------------------------------------------------
Obtener Datos de Inputs: 
Para obtener o modificar datos de un formulario HTML desde JS, podemos hacerlo mediante el DOM. Accediendo a la propiedad value de cada input seleccionado:

Ejemplo:
//CODIGO HTML DE REFERENCIA
  <input id = "nombre" type="text">
  <input id = "edad"   type="number">

//CODIGO JS
document.getElementById("nombre").value = "HOMERO";
document.getElementById("edad").value   = 39;
----------------------------------------------------------------------------------------
Plantillas Literales e innerHTML:
La plantillas son un medio para incluir variables en la estructura HTML de nodos nuevos o existentes , modificando el innerHTML.

ejemplo:
let producto   = { id: 1,  nombre: "Arroz", precio: 125 };
let contenedor = document.createElement("div");
//Definimos el innerHTML del elemento con una plantilla de texto
contenedor.innerHTML = `<h3> ID: ${producto.id}</h3>
                        <p>  Producto: ${producto.nombre}</p>
                        <b> $ ${producto.precio}</b>`;
//Agregamos el contenedor creado al body
document.body.appendChild(contenedor);


otro ejemplo:
const productos = [{ id: 1,  nombre: "Arroz", precio: 125 },
                  {  id: 2,  nombre: "Fideo", precio: 70 },
                  {  id: 3,  nombre: "Pan"  , precio: 50},
                  {  id: 4,  nombre: "Flan" , precio: 100}];

for (const producto of productos) {
    let contenedor = document.createElement("div");
    //Definimos el innerHTML del elemento con una plantilla de texto
    contenedor.innerHTML = `<h3> ID: ${producto.id}</h3>
                            <p>  Producto: ${producto.nombre}</p>
                            <b> $ ${producto.precio}</b>`;
    document.body.appendChild(contenedor);
}
----------------------------------------------------------------------------------------
query selector: El método querySelector() nos permite seleccionar nodos con la misma sintaxis que utilizamos en los selectores de CSS.


ejemplo:
<div id=”contenedor”>
    <p class=”texto”></p>
</div>

// puedo seleccionar la etiqueta <p> siguiendo la sintaxis de CSS para selectores:
let parrafo = document.querySelector("#contenedor p")

/ seleccionar sólo el contenedor por id con #
let contenedor = document.querySelector("#contenedor")

// o por clase:
parrafo = document.querySelector(".texto")

Lo interesante del querySelector es que también aplica a pseudo-clases de CSS, brindando un nivel más avanzado de precisión:

let radioChecked = document.querySelector(".radio:checked")

Suponiendo que tengo elementos html radio button y quiero seleccionar sólo aquel que esté en checked, ésto lo puedo lograr muy fácil con querySelector y la pseudo-clase :checked de CSS.
//!-----------------------------------------------------------------------
 Dia 10 CLASE EVENTOS

 //JavaScript Object Notation (JSON): es un formato basado en texto plano, para representar datos estructurados en la sintaxis de objetos de JavaScript. Es comúnmente utilizado para transmitir datos en aplicaciones web.

//Que son Eventos?: Los eventos son la manera que tenemos en Javascript de controlar las acciones de los usuarios, y definir un comportamiento de la página o aplicación cuando se produzcan.

Con Javascript es posible definir qué sucede cuando se produce un evento, por ejemplo, cuando se realiza un clic en cierto elemento o se inserta un texto en un determinado campo.

//Como Funciona?
JavaScript permite asignar una función a cada uno de los eventos. Reciben el nombre de event handlers o manejadores de eventos.
Así, ante cada evento, JavaScript asigna y ejecuta la función asociada al mismo.

Hay que entender que los eventos suceden constantemente en el navegador.
JavaScript lo que nos permite hacer es escuchar eventos sobre elementos seleccionados. 

Cuando escuchamos el evento que esperamos, se ejecuta la función que definimos en respuesta. 

A esta escucha se la denomina event listener.


//Cómo definir eventos en JS?
Opcion 1: 
El método addEventListener() permite definir qué evento escuchar sobre cualquier elemento seleccionado.
El primer parámetro corresponde al nombre del evento y el segundo a la función de respuesta.

Ejemplo:
  <body>
    <h2>Coder House</h2>
    <button id="btnPrincipal">CLICK</button>
    <script>
      let boton = document.getElementById("btnPrincipal")
      boton.addEventListener("click", respuestaClick)
      function respuestaClick(){
        console.log("Respuesta evento");
      }
    </script>
  </body>

Opcion 2:
Emplear una propiedad del nodo para definir la respuesta al evento. Las propiedades se identifican con el nombre del evento y el prefijo on.
También es posible emplear funciones anónimas para definir los manejadores de eventos.

Ejemplo:

  <body>
    <h2>Coder House</h2>
    <button id="btnPrincipal">CLICK</button>
    <script>
      let boton = document.getElementById("btnPrincipal")
      boton.onclick = () =>{console.log("Respuesta 2")}
    </script>
  </body>

Opcion 3:

Determinar el evento especificando el manejador de evento en el atributo de una etiqueta HTML. La denominación del atributo es idéntica al de la propiedad de la opción 2 (prefijo on). 

La función puede declararse entre la comillas o bien tomarse una referencia existen en el script.

Ejemplo: 

<input type="button" value="CLICK2" onclick="alert('Respuesta 3');" />

//Y cuando conviene usar?
Las opciones 1 y 2 son las recomendadas. 

Si bien se pueden presentar casos de aplicación específicos (por ejemplo, en la opción 1 el nombre del evento puede venir de una variable al usar la propiedad, y esto no puede hacerse en la 2), se identifican como formas de definición de eventos equivalentes.

La opción 3, aunque es de fácil implementación, no es recomendada para proyectos en producción.

No se considera buena práctica declarar funciones y código JavaScript dentro del HTML.

//Eventos mas comunes:

Mouse,teclado,change,inputsubmit,otros

- Eventos Mouse:

mousedown/mouseup: Se oprime/suelta el botón del ratón sobre un elemento.

mouseover/mouseout:  El puntero del mouse se mueve sobre/sale del elemento.

mousemove: El movimiento del mouse sobre el elemento activa el evento.

click: Se activa después de mousedown o mouseup sobre un elemento válido.

Ejemplo:

//CODIGO HTML DE REFERENCIA
<button id="btnMain">CLICK</button>
//CODIGO JS
let boton = document.getElementById("btnMain")
boton.onclick = () => {console.log("Click")}
boton.onmousemove = () => {console.log("Move")}


//Eventos de teclado
Se producen por la interacción del usuario con el teclado. 

Entre ellos se destacarán los que se encuentran a continuación.

keydown: Cuando se presiona.

keyup: Cuando se suelta una tecla.

Ejemplo:

//CODIGO HTML DE REFERENCIA
<input id = "nombre" type="text">
<input id = "edad"   type="number">
//CODIGO JS
let input1 = document.getElementById("nombre")
let input2 = document.getElementById("edad")
input1.onkeyup = () => {console.log("keyUp")}
input2.onkeydown = () => {console.log("keyDown")}

//Eventos onchange
El evento change se activa cuando se detecta un cambio en el valor del elemento. 
 Por ejemplo, mientras se escribe en un input de tipo texto no hay evento change, pero cuando se pasa a otra sección de la aplicación entonces sí ocurre.

Ejemplo:

//CODIGO HTML DE REFERENCIA
<input id = "nombre" type="text">
<input id = "edad"   type="number">
//CODIGO JS
let input1  = document.getElementById("nombre");
let input2  = document.getElementById("edad");
input1.onchange = () => {console.log("valor1")};
input2.onchange = () => 

//Evento input
Si queremos ejecutar una función cada vez que se tipea sobre el campo, conviene trabajar directamente con el evento input.

Ejemplo:


//CODIGO HTML DE REFERENCIA
<input id = "nombre" type="text">

//CODIGO JS
let input1  = document.getElementById("nombre")
input1.addEventListener(‘input’, () => {
     console.log(input1.value)
})


//Evento Submit
El evento submit se activa cuando el formulario es enviado. Normalmente se utiliza para validar el formulario antes de ser enviado al servidor o bien para abortar el envío y procesarlo con JavaScript.

Ejemplo:
//CODIGO HTML DE REFERENCIA
 <form id="formulario">
      <input type="text">
      <input type="number">
      <input type="submit" value="Enviar">
 </form>

//CODIGO JS

let miFormulario      = document.getElementById("formulario");
miFormulario.addEventListener("submit", validarFormulario);

function validarFormulario(e){
    e.preventDefault();
    console.log("Formulario Enviado");    
}

//Otros eventos
Existen otros eventos que podemos utilizar. 

Algunos son eventos estándar definidos en las especificaciones oficiales, mientras que otros son eventos usados internamente por navegadores específicos.

La forma de declararlos es similar a lo abordado en esta clase, lo que necesitamos aprender es bajo qué condición se disparan los eventos que buscamos implementar.

Para conocer más eventos se recomienda verificar la referencia de eventos en la documentación.

//Informacion de eventos
En algunos casos, necesitamos obtener información contextual del evento para poder realizar acciones. 

Por ejemplo, ante el evento submit necesitamos prevenir el comportamiento por defecto para operar correctamente.

Para esto existe en JavaScript el objeto event.

En todos los navegadores modernos se crea de forma automática un parámetro que se pasa a la función manejadora, por lo que no es necesario incluirlo en la llamada.

Ese parámetro puede o no usarse en el handler, pero siempre estará disponible en la llamada.

Ejemplo aplicado:

//Datos del formulario usando event


//CODIGO HTML DE REFERENCIA
 <form id="formulario">
      <input type="text">
      <input type="number">
      <input type="submit" value="Enviar">
    </form>
//CODIGO JS
let miFormulario      = document.getElementById("formulario");
miFormulario.addEventListener("submit", validarFormulario);

function validarFormulario(e){
    //Cancelamos el comportamiento del evento
    e.preventDefault();
    //Obtenemos el elemento desde el cual se disparó el evento
    let formulario = e.target
    //Obtengo el valor del primero hijo <input type="text">
    console.log(formulario.children[0].value); 
    //Obtengo el valor del segundo hijo <input type="number"> 
    console.log(formulario.children[1].value);  
}
//----------------------------------------------------------------
Dia 11 JSON & STORAGE

-Storage o almacenamiento

El objeto Storage (API de almacenamiento web) permite almacenar datos de manera local en el navegador sin necesidad de realizar ninguna conexión con el servidor.
De esta manera, cada cliente puede preservar información de la aplicación.
El navegador nos ofrece dos tipos de storage: localStorage y sessionStorage.

- LocalStorage: Setitem

Los datos almacenados en localStorage (variable global preexistente) se almacenan en el navegador de forma indefinida (o hasta que se borren los datos de navegación del browser): 

La información persiste reinicio de navegador y hasta del sistema operativo.

Para almacenar informacion se usa setitem:

Ejemplo:

// Método ->  localStorage.setItem(clave, valor)
// clave = nombre para identificar el elemento 
// valor = valor/contenido del elemento 
localStorage.setItem('bienvenida', '¡Hola Coder!');
localStorage.setItem('esValido', true);
localStorage.setItem('unNumero', 20);

-Clave - Valor

La información almacenada en el Storage se guarda en la forma de clave-valor. 
Similar al tratamiento de objetos, definimos claves en el storage donde almacenamos valores.

Nota: Podemos ver el Storage en el navegador a través de la pestaña de application

- Localstorage: getitem

Podemos acceder a la información almacenada en localStorage utilizando getItem. Las claves y valores de Storage se guardan en formato de cadena de caracteres (DOMString).

Ejemplo:
let mensaje =  localStorage.getItem('bienvenida');
let bandera =  localStorage.getItem('esValido');
let numero  =  localStorage.getItem('unNumero');

console.log(mensaje); // ‘¡Hola Coder!’
console.log(bandera); // ‘true’
console.log(numero);  // ‘20’

-Recorriendo el storage
Es posible obtener todos los valores almacenados en localStorage o sessionStorage con un bucle.


Pero no podemos usar for...of porque no son objetos iterables, ni for...in porque obtenemos otras propiedades del objeto que no son valores almacenados.

El bucle a emplear es for con el método key:

//Ciclo para recorrer las claves almacenadas en el objeto localStorage

for (let i = 0; i < localStorage.length; i++) {
    let clave = localStorage.key(i);
    console.log("Clave: "+ clave);
    console.log("Valor: "+ localStorage.getItem(clave));
}

- Eliminar del Storage:
Podemos eliminar la información almacenada en sessionStorage o localStorage usando el método removeItem o clear:

ejemplo:
localStorage.setItem('bienvenida', '¡Hola Code!');
sessionStorage.setItem('esValido', true);

localStorage.removeItem('bienvenida');
sessionStorage.removeItem('esValido');
localStorage.clear()    //elimina toda la información
sessionStorage.clear() //elimina toda la información


-JSON: 

- Almacenar Objetos en el Storage

Si queremos almacenar la información de un objeto en un storage, hay que tener en cuenta que tanto la clave como el valor se almacenan en strings. 
Ante cualquier otro tipo a guardar, como un número o un objeto, se convierte a cadena de texto automáticamente. 

Entonces, al buscar almacenar un objeto sin una transformación previa, guardamos [object Object], la conversión por defecto de objeto a string. Para guardar la información correctamente hay que transformar el objeto a JSON.

const producto1 = { id: 2, producto: "Arroz" };
localStorage.setItem("producto1", producto1); // Se guarda [object Object]

-Acceso tipo objeto
Dado que localStorage y sessionStorage son objetos globales, es posible crear y acceder a las claves como si fueran propiedades. Pero esto no es recomendable, porque hay eventos asociados a la modificación del storage cuando se emplea getItem o setItem.

ejemplo:
//Guarda una clave
localStorage.numeroPrueba = 5;

//Leer una clave
alert( localStorage.numeroPrueba ); // 5

let clave = 'toString';	 //toString método reservado	
localStorage[clave] = "6"; //No se guarda este dato

-Ques es JSON:
JavaScript Object Notation (JSON) es un formato basado en texto plano, para representar datos estructurados con la sintaxis de objetos de JavaScript. Es comúnmente utilizado para enviar y almacenar datos en aplicaciones web.

Aunque es muy parecido (casi similar) a la sintaxis de JavaScript, puede ser utilizado independientemente de JavaScript, y muchos entornos de programación poseen la capacidad de leer (convertir; parsear) y generar JSON.
JSON es un string con un formato específico.


- Conversión de objetos y almacenamiento:

--Conversiones de/hacia JSON
Cuando sea necesario enviar un objeto Javascript al servidor o almacenarlo en storage, será necesario convertirlo a un JSON (una cadena) antes de ser enviado.

Para eso usamos los siguientes métodos:

*Stringify:(vamos a pasar un objeto javascript a un JSON)
acepta un objeto como parámetro, y devuelve la forma de texto JSON equivalente.

*parse:(vamos a pasar JSON a un objeto javascript)
recibe un texto JSON como parámetro, y devuelve el objeto JavaScript correspondiente.


-Stringify:

Con JSON.stringify podemos transformar un objeto JavaScript a un string en formato JSON. 

Ejemplo:
const producto1 = { id: 2, producto: "Arroz" };
const enJSON    = JSON.stringify(producto1);

console.log(enJSON); // {"id":2,"producto":"Arroz"}
console.log(typeof producto1); // object
console.log(typeof enJSON);    // string

localStorage.setItem("producto1", enJSON);
// Se guarda {"id":2,"producto":"Arroz"}

-EJEMPLO aplicado: Almacenar array de objetos (1)


const productos = [{ id: 1,  producto: "Arroz", precio: 125 },
                  {  id: 2,  producto: "Fideo", precio: 70 },
                  {  id: 3,  producto: "Pan"  , precio: 50},
                  {  id: 4,  producto: "Flan" , precio: 100}];

const guardarLocal = (clave, valor) => { localStorage.setItem(clave, valor) };

//Almacenar producto por producto
for (const producto of productos) {
    guardarLocal(producto.id, JSON.stringify(producto));
}

// o almacenar array completo
guardarLocal("listaProductos", JSON.stringify(productos));

-Ejemplo aplicado: Almacenar array de objetos (2)


class Producto {
    constructor(obj) {
        this.nombre  = obj.producto.toUpperCase();
        this.precio  = parseFloat(obj.precio);
    }
    sumaIva() {
        this.precio = this.precio * 1.21;
    }
}
//Obtenemos el listado de productos almacenado
const almacenados = JSON.parse(localStorage.getItem("listaProductos"));
const productos = [];

//Iteramos almacenados con for...of para transformar todos sus objetos a tipo producto.
for (const objeto of almacenados)
    productos.push(new Producto(objeto));

//Ahora tenemos objetos productos y podemos usar sus métodos
for (const producto of productos)
    producto.sumaIva();


Muchas veces usamos el Storage para recuperar datos relacionados a la última navegación del usuario. Por ejemplo, su última sesión de login o el último estado de su carrito de compras.
Para esto, pensamos en inicializar las variables de la app consultando el Storage en el momento de inicio.

- Ejemplo aplicado: recuperar estados previos


let usuario;
let usuarioEnLS = JSON.stringify(localStorage.getItem(‘usuario’))


// Si había algo almacenado, lo recupero. Si no le pido un ingreso
if (usuarioEnLS) {
    usuario = usuarioEnLS
} else {
    usuario = prompt(‘Ingrese su nombre de usuario’)
}

//termina aqui

- Ejemplo aplicado: almacenar array de objetos 


let carrito = []
let carritoEnLS = JSON.stringify(localStorage.getItem(‘carrito’))

// Inicializo mi app con carrito como array vacío o con el registro que haya quedado en LS
if (carritoEnLS ) {
    carrito = carritoEnLS 
}

// Función que renderizaría el carrito
renderCarrito( carrito ) 

//termina aqui

-JSON OTROS PUNTOS A TENER EN cuenta

*Las datos en formato JSON se pueden almacenar en archivos externos .json. Example: datos.json

*JSON es sólo un formato de datos -  contiene sólo propiedades, no métodos.

*Una coma o dos puntos mal ubicados pueden producir que un archivo JSON no funcione. Se debe ser cuidadoso para validar cualquier dato que se quiera utilizar. https://jsonformatter.curiousconcept.com/

*A diferencia del código JavaScript en que las propiedades del objeto pueden no estar entre comillas, en JSON sólo las cadenas entre comillas pueden ser utilizadas como propiedades.

-----------------------------------------------------------------------------------
DIA 12 